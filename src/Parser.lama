-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
        { [Left, {[s ("!!"), fun (l , op , r) {Binop (op, Binop("!=", Const(0), l) , Binop("!=", Const(0), r))}]
                  }], 
          [Left, {[s ("&&"), fun (l , op , r) {Binop (op, Binop("!=", Const(0), l) , Binop("!=", Const(0), r))}]
                  }],        
          [Nona, {[s ("!=") | s ("==") | s ("<=") | s ("<") | s (">=") | s (">"), fun(l, op, r) {Binop (op, l, r)}]
                  }],
          [Left , {[s ("+"), fun (l , op , r) {Binop (op, l , r)}] ,
                  [s ("-"), fun (l , op , r) {Binop (op, l , r)}]
                  }],
         [Left , {[s ("*"), fun (l , op , r) {Binop (op, l , r)}] ,
                  [s ("/") | s ("%"), fun (l , op , r) {Binop (op, l , r)}] 
                  }]

        }, primary);



var check = memo $ eta syntax (
    x=lident s[":="] y=exp {Assn(x, y)}
  | kRead x=inbr[s("("), lident, s(")")] {Read (x)}
  | kWrite x=inbr[s("("), exp, s(")")] {Write (x)}
  | kSkip {Skip}
);


var stmt = memo $ eta syntax (
  x=check s[";"] y=stmt {Seq (x, y)}
  | x=check {x}
);

-- Public top-level parser
public parse = stmt;
             
